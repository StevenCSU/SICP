# 程序设计的基本元素

## 练习

### 练习1.1

```scheme
10
12
8
3
6
a
b
19
#f
4
16
6
16
```

### 练习1.2
```scheme
(/ (+ 5 4
        (- 2
           (- 3
              (+ 6
                 (/ 4 5)))))
     (* 3
        (- 6 2)
        (- 2 7)))
```

### 习题1.3
```scheme
;;; 计算平方
(define (square x) (* x x))

;;; 计算平方和
(define (sum-of-squares x y)
    (+ (square x) (square y)))

;;; 计算两个数中较大的数
(define (max x y)
(if (> x y)
    x
    y))

;;; 两个数中较小的数
(define (min x y)
    (if (< x y)
        x
        y))

;;; 求和
(define (sum x y z)
    (sum-of-squares (max x y)
                    (max (min x y)
                         z)))
```

### 习题1.4
将运算符作为函数传递；计算a+|b|

### 习题1.5
> 应用序：先求值参数而后应用

> 正则序：完全展开而后归约
借用SICP解题集的说明：
在应用序中，所有被传入的实际参数都会立即被求值，因此，在使用应用序的解释器里执行 (test 0 (p)) 时，实际参数 0 和 (p) 都会被求值，而对 (p) 的求值将使解释器进入无限循环，因此，如果一个解释器在运行 Ben 的测试时陷入停滞，那么这个解释器使用的是应用序求值模式。

另一方面，在正则序中，传入的实际参数只有在有需要时才会被求值，因此，在使用正则序的解释器里运行 (test 0 (p)) 时， 0 和 (p) 都不会立即被求值，当解释进行到 if 语句时，形式参数 x 的实际参数(也即是 0)会被求值(求值结果也是为 0 )，然后和另一个 0 进行对比((= x 0))，因为对比的值为真(#t),所以 if 返回 0 作为值表达式的值，而这个值又作为 test 函数的值被返回。

因为在正则序求值中，调用 (p) 从始到终都没有被执行，所以也就不会产生无限循环，因此，如果一个解释器在运行 Ben 的测试时顺利返回 0 ，那么这个解释器使用的是正则序求值模式。

另一个需要说明的地方是『形式参数』和『实际参数』两个名词。
对于一个函数来说，它接受的参数的局部名被称为形式参数。

而调用函数时传入的表达式，被称为实际参数。

比如说，对于函数 (define (square x) (* x x)) 来说， x 就是形式参数，当进行调用 (square 2) 时， 2 就是形式参数 x 的实际参数。

当人们只说『参数』而不说明它是『形式参数』还是『实际参数』时，他们一般指的是『形式参数』，但是具体还是要看上下文来决定。

---

## 1.1.7实例：采用牛顿法求平方根

函数与过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件事情之间的普遍性差异的一个具体反映。换一种说法，人们有时也将它说成是说明性的知识与行动性的知识之间的差异。在数学里，人们通常关心的是说明性的描述（是什么），而在计算机科学里，人们则通常关心行动性的描述（怎么做）。

### 练习1.6
new-if只是个普通函数，每个函数的实际参数在传入的时候都会被求值，因此，当使用new-if函数时，无论predicate是真还是假，then-clause和else-clause两个分支都会被求值。

[更好的解释](https://sicp.readthedocs.io/en/latest/chp1/6.html)

### 练习1.7
**待完成**

### 练习1.8
```scheme
;;; 求立方
(define (cube x) (* x x x))

;;; 其余步骤与平方根差不多
(define (cube-root x)
    (cube-root-iter 1.0 x))

(define (cube-root-iter guess x)            
    (if (good-enough? guess x)              
        guess
        (cube-root-iter (improve guess x)
                        x)))

(define (good-enough? guess x)              
    (< (abs (- (cube guess) x))
       0.001))

;;; 代入公式
(define (improve guess x)                  
    (/ (+ (/ x (square guess)) (* 2 guess))
```

---

## 1.1.8 过程作为黑盒抽象
局部名/约束变量/自由/作用域

内部定义和块结构/词法作用域